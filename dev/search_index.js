var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"hankel_correlation_cleaner\nhankel_correlation_cleaner!\njackknife_hankel_correlation_cleaner\njackknife_hankel_correlation_cleaner!\nbootstrap_hankel_correlation_cleaner\nbootstrap_hankel_correlation_cleaner!","category":"page"},{"location":"api/","page":"API","title":"API","text":"hankel_correlation_cleaner\nhankel_correlation_cleaner!(::AbstractVector{T}) where {T<:AbstractFloat}\nhankel_correlation_cleaner!(::AbstractVector{T}, ::AbstractVector{T}) where {T<:AbstractFloat}\njackknife_hankel_correlation_cleaner\njackknife_hankel_correlation_cleaner!\nbootstrap_hankel_correlation_cleaner\nbootstrap_hankel_correlation_cleaner!","category":"page"},{"location":"api/#SmoQyHankelCorrCleaner.hankel_correlation_cleaner","page":"API","title":"SmoQyHankelCorrCleaner.hankel_correlation_cleaner","text":"hankel_correlation_cleaner(\n    noisy_correlations::AbstractVector{T};\n    # KEYWORD ARGUMENTS\n    maxiter::Int,\n    tol::T,\n    positive_curvature::Bool = true,\n    fixed_endpoints::Bool = true,\n    symmetric::Bool = false,\n    verbose::Bool = false\n) where {T<:AbstractFloat}\n\nDenoise imaginary-time correlation data using the Hankel projection method. Returns the tuple (clean_correlations iter, err) where clean_correlation::Vector{T} is a vector of the cleaned correlations, iter::Int is the number of iterations and err::T is the final error.\n\nArguments\n\nnoisy_correlations::AbstractVector{T}: Vector of imaginary time correlation data to be cleaned.\n\nKeyword Arguments\n\nmaxiter::T: Maximum number of iteration used in Dykstra's algorithm.\ntol::T: Tolerance threshold used in Dykstra's algorithm.\npositive_curvature::Bool = false: Whether to project onto a matrix with average anti-diagonals that have strictly positive curvature.\nfixed_endpoints::Bool = true: Whether to fix the correlation values at tau = 0 and tau = beta.\nsymmetric::Bool = false: Whether the imaginary-time correlation data is symmetric about tau = beta2. \nverbose::Bool = false: Whether to print statements tracking the convergence of the denoising process.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyHankelCorrCleaner.hankel_correlation_cleaner!-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"SmoQyHankelCorrCleaner.hankel_correlation_cleaner!","text":"hankel_correlation_cleaner!(\n    correlations::AbstractVector{T};\n    # KEYWORD ARGUMENTS\n    maxiter::Int,\n    tol::T,\n    positive_curvature::Bool = true,\n    fixed_endpoints::Bool = true,\n    symmetric::Bool = false,\n    verbose::Bool = false\n) where {T<:AbstractFloat}\n\nDenoise imaginary-time correlation data using the Hankel projection method. Also return the tuple (iter, err) where iter::Int is the number of iterations and err::T is the final error.\n\nArguments\n\ncorrelations::AbstractVector{T}: Vector of imaginary time correlation data to be cleaned.\n\nKeyword Arguments\n\nmaxiter::T: Maximum number of iteration used in Dykstra's algorithm.\ntol::T: Tolerance threshold used in Dykstra's algorithm.\npositive_curvature::Bool = false: Whether to project onto a matrix with average anti-diagonals that have strictly positive curvature.\nfixed_endpoints::Bool = true: Whether to fix the correlation values at tau = 0 and tau = beta.\nsymmetric::Bool = false: Whether the imaginary-time correlation data is symmetric about tau = beta2. \nverbose::Bool = false: Whether to print statements tracking the convergence of the denoising process.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyHankelCorrCleaner.hankel_correlation_cleaner!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"SmoQyHankelCorrCleaner.hankel_correlation_cleaner!","text":"hankel_correlation_cleaner!(\n    clean_correlations::AbstractVector{T},\n    noisy_correlations::AbstractVector{T};\n    # KEYWORD ARGUMENTS\n    maxiter::Int,\n    tol::T,\n    positive_curvature::Bool = true,\n    fixed_endpoints::Bool = true,\n    symmetric::Bool = false,\n    verbose::Bool = false\n) where {T<:AbstractFloat}\n\nDenoise imaginary-time correlation data using the Hankel projection method. Also return the tuple (iter, err) where iter::Int is the number of iterations and err::T is the final error.\n\nArguments\n\nclean_correlations::AbstractVector{T}: Vector to contain cleaned/denoised imaginary-time correlation data.\nnoisy_correlations::AbstractVector{T}: Noisy imaginary-time correlation data.\n\nKeyword Arguments\n\nmaxiter::T: Maximum number of iteration used in Dykstra's algorithm.\ntol::T: Tolerance threshold used in Dykstra's algorithm.\npositive_curvature::Bool = false: Whether to project onto a matrix with average anti-diagonals that have strictly positive curvature.\nfixed_endpoints::Bool = true: Whether to fix the correlation values at tau = 0 and tau = beta.\nsymmetric::Bool = false: Whether the imaginary-time correlation data is symmetric about tau = beta2. \nverbose::Bool = false: Whether to print statements tracking the convergence of the denoising process.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyHankelCorrCleaner.jackknife_hankel_correlation_cleaner","page":"API","title":"SmoQyHankelCorrCleaner.jackknife_hankel_correlation_cleaner","text":"jackknife_hankel_correlation_cleaner(;\n    # KEYWORD ARGUMENTS\n    correlation_bins::AbstractMatrix{T},\n    sign_bins::AbstractVector{T} = ones(eltype(correlation_bins), size(correlation_bins, 2)),\n    maxiter::Int = 1000,\n    tol::T = 1e-4,\n    positive_curvature::Bool = false,\n    fixed_endpoints::Bool = true,\n    symmetric::Bool = false,\n    covariance::Bool = false\n) where {T<:AbstractFloat}\n\nDenoise binned imaginary-time correlation data, propagating the error using the jackknife algorithm. Returns the mean and error of the denoised imaginary-time correlation data.\n\nArguments\n\nclean_correlations_mean::AbstractVector{T}: Vector to contain denoised imaginary-time correlations.\nclean_correlations_error::AbstractVector{T}: Vector to contain error associated with denoised imaginary-time correlations.\ncorrelation_bins::AbstractMatrix{T}: Binned imaginary-time correlations where the columns correspond to the bins and the rows to the imaginary time slices.\n\nKeyword Arguments\n\nsign_bins::AbstractVector{T} = ones(eltype(correlation_bins), size(correlation_bins, 2)): For data generated via a quantum Monte Carlo simulation with a sign problem, the average sign associated with each bin.\nmaxiter::T: Maximum number of iteration used in Dykstra's algorithm.\ntol::T: Tolerance threshold used in Dykstra's algorithm.\npositive_curvature::Bool = false: Whether to project onto a matrix with average anti-diagonals that have strictly positive curvature.\nfixed_endpoints::Bool = true: Whether to fix the correlation values at tau = 0 and tau = beta.\nsymmetric::Bool = false: Whether the imaginary-time correlation data is symmetric about tau = beta2. \ncovariance::Bool = false: If true, this method also returns the covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyHankelCorrCleaner.jackknife_hankel_correlation_cleaner!","page":"API","title":"SmoQyHankelCorrCleaner.jackknife_hankel_correlation_cleaner!","text":"jackknife_hankel_correlation_cleaner!(\n    clean_correlations_mean::AbstractVector{T},\n    clean_correlations_error::AbstractVector{T},\n    correlation_bins::AbstractMatrix{T};\n    # KEYWORD ARGUMENTS\n    sign_bins::AbstractVector{T} = ones(eltype(correlation_bins), size(correlation_bins, 2)),\n    maxiter::Int = 1000,\n    tol::T = 1e-4,\n    positive_curvature::Bool = false,\n    fixed_endpoints::Bool = true,\n    symmetric::Bool = false,\n    covariance::Bool = false\n) where {T<:AbstractFloat}\n\nDenoise binned imaginary-time correlation data, propagating the error using the jackknife algorithm.\n\nArguments\n\nclean_correlations_mean::AbstractVector{T}: Vector to contain denoised imaginary time correlations.\nclean_correlations_error::AbstractVector{T}: Vector to contain error associated with denoised imaginary time correlations.\ncorrelation_bins::AbstractMatrix{T}: Binned imaginary time correlations where the columns correspond to the bins and the rows to the imaginary time slices.\n\nKeyword Arguments\n\nsign_bins::AbstractVector{T} = ones(eltype(correlation_bins), size(correlation_bins, 2)): For data generated via a quantum Monte Carlo simulation with a sign problem, the average sign associated with each bin.\nmaxiter::T: Maximum number of iteration used in Dykstra's algorithm.\ntol::T: Tolerance threshold used in Dykstra's algorithm.\npositive_curvature::Bool = false: Whether to project onto a matrix with average anti-diagonals that have strictly positive curvature.\nfixed_endpoints::Bool = true: Whether to fix the correlation values at tau = 0 and tau = beta.\nsymmetric::Bool = false: Whether the imaginary-time correlation data is symmetric about tau = beta2. \ncovariance::Bool = false: If true, this method also returns the covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyHankelCorrCleaner.bootstrap_hankel_correlation_cleaner","page":"API","title":"SmoQyHankelCorrCleaner.bootstrap_hankel_correlation_cleaner","text":"bootstrap_hankel_correlation_cleaner(;\n    # KEYWORD ARGUMENTS\n    correlation_bins::AbstractMatrix{T},\n    sign_bins::AbstractVector{T} = ones(eltype(correlation_bins), size(correlation_bins, 2)),\n    N_bootstrap::Int = 100,\n    maxiter::Int = 1000,\n    tol::T = 1e-4,\n    positive_curvature::Bool = false,\n    fixed_endpoints::Bool = true,\n    symmetric::Bool = false,\n    covariance::Bool = false\n) where {T<:AbstractFloat}\n\nDenoise binned imaginary-time correlation data, propagating the error via bootstrapping.\n\nArguments\n\ncorrelation_bins::AbstractMatrix{T}: Binned imaginary time correlations where the columns correspond to the bins and the rows to the imaginary time slices.\n\nKeyword Arguments\n\nsign_bins::AbstractVector{T} = ones(eltype(correlation_bins), size(correlation_bins, 2)): For data generated via a quantum Monte Carlo simulation with a sign problem, the average sign associated with each bin.\nN_bootstrap::Int = 100: Number of bootstrap samples used to calculate the error.\nmaxiter::T: Maximum number of iteration used in Dykstra's algorithm.\ntol::T: Tolerance threshold used in Dykstra's algorithm.\npositive_curvature::Bool = false: Whether to project onto a matrix with average anti-diagonals that have strictly positive curvature.\nfixed_endpoints::Bool = true: Whether to fix the correlation values at tau = 0 and tau = beta.\nsymmetric::Bool = false: Whether the imaginary-time correlation data is symmetric about tau = beta2. \ncovariance::Bool = false: If true, this method also returns the covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyHankelCorrCleaner.bootstrap_hankel_correlation_cleaner!","page":"API","title":"SmoQyHankelCorrCleaner.bootstrap_hankel_correlation_cleaner!","text":"bootstrap_hankel_correlation_cleaner!(;\n    # KEYWORD ARGUMENTS\n    clean_correlations_mean::AbstractVector{T},\n    clean_correlations_error::AbstractVector{T},\n    correlation_bins::AbstractMatrix{T},\n    sign_bins::AbstractVector{T} = ones(eltype(correlation_bins), size(correlation_bins, 2)),\n    N_bootstrap::Int = 100,\n    maxiter::Int = 1000,\n    tol::T = 1e-4,\n    positive_curvature::Bool = false,\n    fixed_endpoints::Bool = true,\n    symmetric::Bool = false,\n    covariance::Bool = false\n) where {T<:AbstractFloat}\n\nDenoise binned imaginary-time correlation data, propagating the error via bootstrapping.\n\nArguments\n\nclean_correlations_mean::AbstractVector{T}: Vector to contain denoised imaginary time correlations.\nclean_correlations_error::AbstractVector{T}: Vector to contain error associated with denoised imaginary time correlations.\ncorrelation_bins::AbstractMatrix{T}: Binned imaginary time correlations where the columns correspond to the bins and the rows to the imaginary time slices.\n\nKeyword Arguments\n\nsign_bins::AbstractVector{T} = ones(eltype(correlation_bins), size(correlation_bins, 2)): For data generated via a quantum Monte Carlo simulation with a sign problem, the average sign associated with each bin.\nN_bootstrap::Int = 100: Number of bootstrap samples used to calculate the error.\nmaxiter::T: Maximum number of iteration used in Dykstra's algorithm.\ntol::T: Tolerance threshold used in Dykstra's algorithm.\npositive_curvature::Bool = false: Whether to project onto a matrix with average anti-diagonals that have strictly positive curvature.\nfixed_endpoints::Bool = true: Whether to fix the correlation values at tau = 0 and tau = beta.\nsymmetric::Bool = false: Whether the imaginary-time correlation data is symmetric about tau = beta2. \ncovariance::Bool = false: If true, this method also returns the covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Developer-API","page":"API","title":"Developer API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SmoQyHankelCorrCleaner.dykstra!\nSmoQyHankelCorrCleaner.project_psd!\nSmoQyHankelCorrCleaner.project_hankel!\nSmoQyHankelCorrCleaner.project_positive_curvature!\nSmoQyHankelCorrCleaner.init_hankel_matrix\nSmoQyHankelCorrCleaner.init_hankel_matrix!","category":"page"},{"location":"api/#SmoQyHankelCorrCleaner.dykstra!","page":"API","title":"SmoQyHankelCorrCleaner.dykstra!","text":"dykstra!(;\n    # KEYWORD ARGUMENTS\n    H::AbstractArray{T},\n    projections!::Vector{Function},\n    tol::T,\n    maxiter::Int,\n    H0::AbstractArray{T} = zero(H),\n    P0::AbstractArray{T} = zero(H),\n    Ps::AbstractArray{T} = zeros(eltype(H), size(H)..., length(projections!)),\n    verbose::Bool = false,\n    projection_names::Vectors{String} = String[]\n) where {T<:AbstractFloat}\n\nPerform Dykstra's algorithm on an input array H given a vector projections! for projection functions that modify H in place. This method is based on the implementation found in the Dykstra python package.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyHankelCorrCleaner.project_psd!","page":"API","title":"SmoQyHankelCorrCleaner.project_psd!","text":"project_psd!(\n    H::AbstractMatrix{T},\n    A::AbstractMatrix{T} = similar(H)\n) where {T<:AbstractFloat}\n\nModifying H in-place, project it onto the nears positive semidefinite matrix by setting all the negative eigenvalues to zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyHankelCorrCleaner.project_hankel!","page":"API","title":"SmoQyHankelCorrCleaner.project_hankel!","text":"project_hankel!(\n    H::AbstractMattrix{T},\n    endpoints::Tuple{T,T} = (NaN, NaN)\n) where {T<:AbstractFloat}\n\nModifying the matrix H in-place, project it onto the closest Hankel matrix as defined by the Frobenius norm, by replacing each anti-diagonal by its average value. If finite endpoints are passed, then the values of H[1,1] and H[end,end] are fixed to those values respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyHankelCorrCleaner.project_positive_curvature!","page":"API","title":"SmoQyHankelCorrCleaner.project_positive_curvature!","text":"project_positive_curvature!(\n    H::AbstractMatrix{T},\n    endpoints::Tuple{T,T} = (NaN, NaN)\n) where {T<:AbstractFloat}\n\nProject the matrix H onto the nearest matrix, as measured by the Frobenius norm, that has anti-diagonal average values that have strictly positive curvature i.e. if you take the second finite difference of anti-diagonal average values the result values are strictly positive. If the endpoints are real numbers, then the H[1,1] and H[end:end] set set equal to the passed values.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyHankelCorrCleaner.init_hankel_matrix","page":"API","title":"SmoQyHankelCorrCleaner.init_hankel_matrix","text":"init_hankel_matrix(\n    correlations::AbstractVector{T}\n) where {T<:AbstractFloat}\n\nAllocate, initialize and return the Hankel matrix based on the vector of correlations.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyHankelCorrCleaner.init_hankel_matrix!","page":"API","title":"SmoQyHankelCorrCleaner.init_hankel_matrix!","text":"\"     inithankelmatrix!(         H::AbstractMatrix{T},         correaltions::AbstractVector{T}     ) where {T<:AbstractFloat}\n\nInitialize the Hankel matrix H in-place based on the vector of correlations.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"EditURL = \"../usage.jl\"","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here we demonstrate how to use the SmoQyHankelCorrCleaner.jl package.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using SmoQyHankelCorrCleaner\nusing Statistics\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"As an initial example, we consider the atomic Hubbard model","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"H = U (hatn_uparrow - tfrac12)(hatn_downarrow - tfrac12) - mu (hatn_uparrow + hatn_downarrow)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"with the correspoding imaginary-time Green's function given by","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"G_sigma(tau) = langle hatc_sigma^dagger(tau) hatc_sigma^phantomdagger(0) rangle\n    = frace^tau U2 + tau mu - beta U4 + e^-tau U2 + tau mu + beta U4 + beta mue^-beta U4 + 2 e^beta (U4+mu) + e^-beta(U4-2mu)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"where tau in 0beta) and beta = 1T is the inverse temperature.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Evaluate G(τ) for the atomic Hubbard model\nfunction atomic_hubbard_greens(τ, β, U, μ)\n\n    Z   = exp(-β*U/4) + 2*exp(β*(U/4+μ)) + exp(-β*(U/4-2*μ))\n    ZGτ = exp(τ*U/2 + τ*μ - β*U/4) + exp(-τ*U/2 + τ*μ + β*U/4 + β*μ)\n    Gτ  = ZGτ / Z\n    return Gτ\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now we assign parameter values in our model, including the inverse temperature.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Hubbard repulsion\nU = 5.0\n\n# Chemical potential\nμ = 2.50\n\n# Inverse temperature\nβ = 5.0;\nnothing #hide","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Next we evaulate the Green's funciton on a regular imaginary-time tau grid.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Discretization interval\nΔτ = 0.05\n\n# Imaginary-time values\nτ = collect(range(start = 0.0, stop = β, step = Δτ))\n\n# Evaluate G(τ)\nGτ_exact = atomic_hubbard_greens.(τ, β, U, μ)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now let us define some synthetic noisy data.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Add normal random noise to Green's function\nGτ_noisy = Gτ_exact + 0.007 * randn(length(τ))\n\n# Reduce noise for G(τ = 0) point\nGτ_noisy[1] = Gτ_exact[1] +  0.002 * randn()\n\n# Ensure that noisy data still satisty the sum rule G(τ=0) + G(τ=β) = 1\nGτ_noisy[end] = 1 - Gτ_noisy[1]\n\nGτ_noisy","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now let us denoise the noisy Green's function using the hankel projection method.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Denoise imaginary-time Green's function\nGτ_clean, iter, err =  hankel_correlation_cleaner(\n    Gτ_noisy,\n    maxiter = 1000,\n    tol = 1e-3,\n    positive_curvature = true,\n    fixed_endpoints = true,\n    symmetric = false,\n    verbose = false\n)\n\n(iter, err)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now let us plot the result to see how this all looks.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"fig = Figure(\n    size = (700, 700),\n    fonts = (; regular= \"CMU Serif\"),\n    figure_padding = 10\n)\n\nax = Axis(fig[1, 1],\n    aspect = 1,\n    xlabel = L\"\\tau\",\n    ylabel = L\"G_\\sigma(\\tau)\",\n    xlabelsize = 36,\n    ylabelsize = 36,\n    xticklabelsize = 30,\n    yticklabelsize = 30,\n)\n\nxlims!(ax, 0.0, β)\n\nscatter!(\n    τ, Gτ_noisy,\n    color = :blue, markersize = 9, label = \"Noisy\"\n)\n\nlines!(\n    τ, Gτ_exact,\n    linewidth = 7, alpha = 1.0, color = :black, linestyle = :dash, label = \"Exact\"\n)\n\nlines!(\n    τ, Gτ_clean,\n    linewidth = 4, color = :red, linestyle = :solid, label = \"Denoised\"\n)\naxislegend(ax, halign = :left, valign = :top, labelsize = 34)\n\nfig","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Often noisy imaginary-time correlation data is generated by a quantum Monte Carlo simulation, or some other stochastic process, in which you have a set of samples or bins. In this case it is desirable to propagate errors through the denoising process to get a final error for the denoised correlation function. Below we will demonstrate two ways of doing this, one using the jackknife method and the other via bootstrap resampling.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To start let us generated binned noisy synthetic G(tau) data.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Number of samples\nN_bins = 32\n\n# Generate synthetic binned data\nGτ_binned = hcat((Gτ_exact for b in 1:N_bins)...) + 0.08 * randn(length(τ), N_bins)\n\n# Reduce noise for G(τ = 0)\n@. Gτ_binned[1,:] = Gτ_exact[1] +  0.02 * randn()\n\n# Ensure that noisy data still satisty the sum rule G(τ=0) + G(τ=β) = 1\n@. Gτ_binned[end,:] = 1.0 - Gτ_binned[1,:]\n\nGτ_binned","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Before we demonstrate how to propagate errors through the denoising process, let us first calculate mean and error of our binned G(tau) data first. Having calculated the mean and error of our synthetic binned G(tau) data, let us also plot it really quickly as a reference.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Calculate mean of binned data\nGτ_avg = vec(mean(Gτ_binned, dims=2))\n\n# Calculate standard deviation of the mean of binned data\nGτ_err = vec(std(Gτ_binned, dims=2)) / sqrt(N_bins)\n\n# Get the average plus or minus the error\nGτ_avg_lower = Gτ_avg - Gτ_err\nGτ_avg_upper = Gτ_avg + Gτ_err;\n\n# Now we plot the average with the one standard deviation confidence interval\nfig = Figure(\n    size = (700, 700),\n    fonts = (; regular= \"CMU Serif\"),\n    figure_padding = 10\n)\n\nax = Axis(fig[1, 1],\n    aspect = 1,\n    xlabel = L\"\\tau\",\n    ylabel = L\"G_\\sigma(\\tau)\",\n    xlabelsize = 36,\n    ylabelsize = 36,\n    xticklabelsize = 30,\n    yticklabelsize = 30,\n)\n\nb_err = band!(\n    τ, Gτ_avg_lower, Gτ_avg_upper,\n    color = (:red, 0.2)\n)\ntranslate!(b_err, 0, 0, 0.0)\n\nl_err = lines!(\n    τ, Gτ_exact,\n    linewidth = 3, alpha = 1.0, color = :black, linestyle = :solid, label = \"Exact\"\n)\ntranslate!(l_err, 0, 0, 2.0)\n\nl_avg = lines!(\n    τ, Gτ_avg,\n    linewidth = 3, color = :red, linestyle = :solid, label = \"Mean\"\n)\ntranslate!(l_avg, 0, 0, 1.0)\n\nl_lower = lines!(\n    τ, Gτ_avg_lower,\n    linewidth = 2, alpha = 0.6, color = :red, linestyle = :solid\n)\ntranslate!(l_lower, 0, 0, 1.0)\n\nl_upper = lines!(\n    τ, Gτ_avg_upper,\n    linewidth = 2, alpha = 0.6, color = :red, linestyle = :solid\n)\ntranslate!(l_upper, 0, 0, 1.0)\n\nxlims!(ax, 0.0, β)\n\naxislegend(ax, halign = :left, valign = :top, labelsize = 34)\n\nfig","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now let us denoise the binned G(tau) while propagating the errors using the jackknife method.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Denoise and propagate errors with jackknife\nGτ_jackknife_avg, Gτ_jackknife_err, Gτ_jackknife_cov = jackknife_hankel_correlation_cleaner(\n    correlation_bins = Gτ_binned,\n    sign_bins = ones(length(τ)),\n    maxiter = 1000,\n    tol= 1e-3,\n    positive_curvature = true,\n    fixed_endpoints = true,\n    symmetric = false,\n    covariance = true\n)\n\n# Get the average plus or minus the error\nGτ_jackknife_avg_lower = Gτ_jackknife_avg - Gτ_jackknife_err\nGτ_jackknife_avg_upper = Gτ_jackknife_avg + Gτ_jackknife_err;\n\n# Now we plot the average with the one standard deviation confidence interval\nfig = Figure(\n    size = (700, 700),\n    fonts = (; regular= \"CMU Serif\"),\n    figure_padding = 10\n)\n\nax = Axis(fig[1, 1],\n    aspect = 1,\n    xlabel = L\"\\tau\",\n    ylabel = L\"G_\\sigma(\\tau)\",\n    xlabelsize = 36,\n    ylabelsize = 36,\n    xticklabelsize = 30,\n    yticklabelsize = 30,\n)\n\nb_err = band!(\n    τ, Gτ_jackknife_avg_lower, Gτ_jackknife_avg_upper,\n    color = (:red, 0.2)\n)\ntranslate!(b_err, 0, 0, 0.0)\n\nl_err = lines!(\n    τ, Gτ_exact,\n    linewidth = 3, alpha = 1.0, color = :black, linestyle = :solid, label = \"Exact\"\n)\ntranslate!(l_err, 0, 0, 2.0)\n\nl_avg = lines!(\n    τ, Gτ_jackknife_avg,\n    linewidth = 3, color = :red, linestyle = :solid, label = \"Denoised Jackknife Mean\"\n)\ntranslate!(l_avg, 0, 0, 1.0)\n\nl_lower = lines!(\n    τ, Gτ_jackknife_avg_lower,\n    linewidth = 2, alpha = 0.6, color = :red, linestyle = :solid\n)\ntranslate!(l_lower, 0, 0, 1.0)\n\nl_upper = lines!(\n    τ, Gτ_jackknife_avg_upper,\n    linewidth = 2, alpha = 0.6, color = :red, linestyle = :solid\n)\ntranslate!(l_upper, 0, 0, 1.0)\n\nxlims!(ax, 0.0, β)\n\naxislegend(ax, halign = :left, valign = :top, labelsize = 34)\n\nfig","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Lastly, let us denoise the binned G(tau) but instead propagate error using bootstrap resampling.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Denoise and propagate errors with bootstrap resampling\nGτ_bootstrap_avg, Gτ_bootstrap_err, Gτ_bootstrap_cov = bootstrap_hankel_correlation_cleaner(\n    correlation_bins = Gτ_binned,\n    sign_bins = ones(length(τ)),\n    N_bootstrap = 100,\n    maxiter = 1000,\n    tol= 1e-3,\n    positive_curvature = true,\n    fixed_endpoints = true,\n    symmetric = false,\n    covariance = true\n)\n\n# Get the average plus or minus the error\nGτ_bootstrap_avg_lower = Gτ_bootstrap_avg - Gτ_bootstrap_err\nGτ_bootstrap_avg_upper = Gτ_bootstrap_avg + Gτ_bootstrap_err;\n\n# Now we plot the average with the one standard deviation confidence interval\nfig = Figure(\n    size = (700, 700),\n    fonts = (; regular= \"CMU Serif\"),\n    figure_padding = 10\n)\n\nax = Axis(fig[1, 1],\n    aspect = 1,\n    xlabel = L\"\\tau\",\n    ylabel = L\"G_\\sigma(\\tau)\",\n    xlabelsize = 36,\n    ylabelsize = 36,\n    xticklabelsize = 30,\n    yticklabelsize = 30,\n)\n\nb_err = band!(\n    τ, Gτ_bootstrap_avg_lower, Gτ_bootstrap_avg_upper,\n    color = (:red, 0.2)\n)\ntranslate!(b_err, 0, 0, 0.0)\n\nl_err = lines!(\n    τ, Gτ_exact,\n    linewidth = 3, alpha = 1.0, color = :black, linestyle = :solid, label = \"Exact\"\n)\ntranslate!(l_err, 0, 0, 2.0)\n\nl_avg = lines!(\n    τ, Gτ_bootstrap_avg,\n    linewidth = 3, color = :red, linestyle = :solid, label = \"Denoised Bootstrap Mean\"\n)\ntranslate!(l_avg, 0, 0, 1.0)\n\nl_lower = lines!(\n    τ, Gτ_bootstrap_avg_lower,\n    linewidth = 2, alpha = 0.6, color = :red, linestyle = :solid\n)\ntranslate!(l_lower, 0, 0, 1.0)\n\nl_upper = lines!(\n    τ, Gτ_bootstrap_avg_upper,\n    linewidth = 2, alpha = 0.6, color = :red, linestyle = :solid\n)\ntranslate!(l_upper, 0, 0, 1.0)\n\nxlims!(ax, 0.0, β)\n\naxislegend(ax, halign = :left, valign = :top, labelsize = 34)\n\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SmoQyHankelCorrCleaner","category":"page"},{"location":"#SmoQyHankelCorrCleaner.jl","page":"Home","title":"SmoQyHankelCorrCleaner.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SmoQyHankelCorrCleaner.jl the method introduced in the paper \"Denoising of Imaginary Time Response Functions with Hankel Projections\" for denoising imaginary time correlation data, the citation for which is given below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Yu2024Denoising,\n  title={Denoising of Imaginary Time Response Functions with Hankel projections},\n  author={Yu, Yang and Kemper, Alexander F and Yang, Chao and Gull, Emanuel},\n  journal={arXiv preprint arXiv:2403.12349},\n  year={2024}\n}","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SmoQyHankelCorrCleaner.jl, simply open the Julia REPL and run the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add SmoQyHankelCorrCleaner","category":"page"},{"location":"","page":"Home","title":"Home","text":"or equivalently via Pkg do","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"SmoQyHankelCorrCleaner\")","category":"page"}]
}
